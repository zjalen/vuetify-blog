<div style="text-align:center"><img src="../storage/images/20181115-160119-962.jpg"><p></p><p></p></div>

>*本文来源于网络重新整理，原链接见文末*

## 什么是正则表达式?
Regular Expression，简称 RE/Regex。用于匹配字符串中字符组合的模式。我们可以通过认识集合中有限的字符(正则表达式中的元字符)来识别属于这种集合的任意多的其他字符。
这样来讲，其实你之前已经接触过正则了，只是你不知道而已。比如:

```
Ctrl + F
```

字符串子串匹配问题， 本质上也是正则。

```bash
echo "shellvon" | grep von
```

我们在命令行下经常使用的 grep，其实你的 von 也算正则了

## 基础用法
上述 `grep` 是一种匹配方法，可是当我们要匹配的都是数字或者都是字母的时候。或者100个相同字母的时候，写起来就啰嗦复杂了。也谈不上模式！所以呢，我们引入了一种这样功能的字符: 自己不代表自己原本含义，而都有特殊含义的字符。比如，我希望点号 .可以匹配任意字符，具有这种功能的字符，称之为元字符(metacharacters)。

### 元字符
我们有时候会用一些字符来表示\代替其他字符，比如用 `*` 代替脏话，类似的方式就需要用正则表达式来实现匹配查找替换显示，我们可以用有限数量的元字符来表示无限数量的字符。

|     元字符    |  表示含义|
| ------------ | ------------ |
|^与&|(^)行的开始与行的结束(&)|
|[]与[^]|字符组([])和排除字符组([^]) ^必须放在开始|
|-|连字符，必须放在字符组内，表示范围，如：[0-9]|
|.|匹配任意字符(可能会排除\n)|
| * 与 + |量词，匹配之前的字符出现次数， * >= 0 次， + >= 1 次|
|{n}与{n,}与{n,m}|区间量词，匹配次数，{n}匹配n次，{n,m}匹配 n~m 次|
| &#124; |或者|
| ? |量词，? 之前的字符为可选字符|
|()|字符集，完全匹配括号里的数据|
|\\|转义字符，用来匹配一些特殊符号(如元字符，`\*` 表示匹配 `*` )|

*注：`-` 连字符如果要表示区间，必须有起始，否则 `-` 只表示 `-` 字符本身，如 `[-1]` 表示 `-` 和 `1` 两个字符的合集，再如 `[0-5-7]` 表示 `0,1,2,3,4,5,-,7` 这几个字符的集*

```php
"[Tt]he" => The car parked in the garage
            ^^^               ^^^
"[^c]ar" => The car parked in the garage
                    ^^^           ^^^
"c.+t" => The fat cat sat on the mat
                  ^^^^^^^^^^^^^^^^^^
                   ¦----被(.+)匹配-¦
"b.g" => baidugoogle big bug bag
                     ^^^ ^^^ ^^^
```

### 子表达式
我们在实际的运算过程中，经常会碰到一些不能一次性表达的复杂算法，这时候就可以将复杂的表达式拆分为几组表达式来组成完整的范围，这些简单的表达式称之为 **子表达式**。它们通常用 `|` 符号来分隔或放在括号内包括起来。例如： `d(a|i)d` 用来表示 `dad` 或 `did`。

下面是一个思考题：如何用元字符表示 `0-23` 这个数字范围？初学者可能会直接想到 `[0-23]` 区间字符组不是刚好表示这个区间范围吗？很遗憾并不是，因为 `-` 连字符的开始和结束只能用一个字符来表示（16进制例外）。所以表达式 `[0-23]` 所表示的是 `[0123]` 这四个数字的范围。

这时候我们用子表达式的概念，将这个区间范围进行拆分就能比较方便的表达了。

`[0-9]` 可以匹配0-9范围
`1[0-9]` 可以匹配10-19范围
`2[0-3]` 可以匹配20-23范围

最后用 `|` 符号连接 `[0-9]|1[0-9]|2[0-3]` 得到我们所要的表达式结果。

> 如果更加复杂一点呢，比如要匹配一个 IPv4 地址呢？其实原理一样，只是数字范围变成了0-255。
更为复杂的就是，考虑匹配一个日期，需要考虑月份和天数的关系，甚至还有闰年，**通常这种时候你还要用正则的话，你估计已经开始过度使用正则了，你需要避免这样**。

### 常用简写
有一些非常常用的表达式，如数字 `[0-9]` 或字母 `[a-z]`，为了写起来简便，有替代的简写用法帮助我们更好记忆更方便书写
|     简写字符    |  表示含义|
| ------------ | ------------ |
|.| 表示任意字符|
|\d 和 \D|表示数字`\d`和非数字`\D`|
|\w 和 \W|`\w`表示`[a-zA-Z0-9]`，`\W`表示非这些字符|
|\s 和 \S|`\s`表示匹配所有空格，`\S`表示非空格|

以下是几个例子：
```php
"\d{2,3}" => The number was 9.9997.
                              ^^^
"car\sis" => The car is parked.
                 ^^^^^^
"^\d+" => 13 is less than 18.
          ^^
``` 
*以上末尾 `.` 仅表示结束，不属于匹配范围*

### 捕获、非捕获和反向引用
从上述子表达式中，我们知道括号表示一个整体，另外括号还有一个作用是 **捕获**。捕获的意思是我们在使用正则表达式去匹配的时候，正则引擎会记录我们匹配的结果，并取一个名字，方便我们在匹配完毕或匹配过程中需要使用这些结果的时候来进行引用。

> 正则引擎的取名规则：每个括号对为一组，以左括号的出现顺序为顺序，从 1 开始，从左向右自动累加组号。

例如： `(hello (world (regex)))` 的分组如下：
```
1. hello world regex <-- 第一个组，组号为1，后面以此类推
2. world regex       <-- 第二个组
3. regex              <-- 第三个组
```
得到以上组号之后，我们便可以通过组号来使用匹配结果，这个方式叫 **反向引用**。
例如：
```php
"([ab])\1" => abcdebbcde
                   ^^
                    ¦-----这个`b`就是因为前面的([ab])匹配到了一个字符b。我们可以用\1来引用起之前结果
```
有时我们的匹配不需要捕获，因为捕获过程正则引擎会一直记录组号，组号数字也在增大，效率降低过多组号也不方便我们去使用，所以对应的还有 **非捕获**，写法相似，只需要在表达式括号内前面加上字符 `?:` 即可。
|     语法   |  表示含义| 举例|
| ------------ | ------------ | --- |
| (a) | 匹配 `a` 并捕获，设置组号 | (\d{3})+\d|
| (?:a) | 匹配 `a` 但不捕获 | abc(?:d\|e) 匹配 `abcd` 和 `abce`|

> 显然，如果一个复杂的表达式里面引入过多的非捕获，虽然可以减少正则引擎去记忆，但是这也会增加我们阅读正则表达式的难度，所以，请深思熟虑是否有必要为了这么一点性能而用非捕获。
另一方面，在复杂的正则表达式中如果全部使用了捕获，试想一下这种情况:
有天你突然把某个括号删除了，或者需要在中间某处增加一个括号，会产生什么样的影响？
聪明的你应该想到了，会导致组号的变更。比如原来是\3,现在可能变成了\2或者\4，或者其他。
所以捕获如果按照数字取名字实在不是很好。于是写 Python 正则的那群人说，要不给这些组取名字的事情交给用户吧，比如叫张三，李四。这种技术叫做
命名捕获。大概是这么写的(?P<myname>hello) 它不仅具有原来数字的乳名\1，还有用户你自己为它取的名字myname。这种方式很棒，.Net觉得不错也抄袭了过去，只不过语法不一样罢了。

参考来源：[30分钟学正则](https://von.sh/2017/11/29/learn-regex-in-30-minutes "30分钟学正则")